# -*- coding: utf-8 -*-
"""Poker Optimization Model App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15YqJ5zuBzvZEFsLVe46LQO3d34IpwcU_
"""



# Commented out IPython magic to ensure Python compatibility.
# %%writefile streamlit_app/app.py
# import streamlit as st
# import torch
# import torch.nn as nn
# import numpy as np
# from treys import Card, Evaluator
# import pandas as pd
# import plotly.express as px
# 
# # Define PokerQNetwork class (original with 10 state features)
# class PokerQNetwork(nn.Module):
#     def __init__(self):
#         super(PokerQNetwork, self).__init__()
#         self.card_embedding = nn.Embedding(53, 16)
#         self.hole_conv = nn.Conv1d(16, 32, kernel_size=2)
#         self.community_conv = nn.Conv1d(16, 32, kernel_size=3, padding=1)
#         self.attention = nn.MultiheadAttention(embed_dim=32, num_heads=4, batch_first=True)
#         self.state_fc = nn.Linear(10, 64)  # Original state input size
#         total_features = 32 + 32 + 64
#         self.fc1 = nn.Linear(total_features, 512)
#         self.fc2 = nn.Linear(512, 256)
#         self.fc3 = nn.Linear(256, 128)
#         self.fc4 = nn.Linear(128, 3)
#         self.dropout = nn.Dropout(0.2)
#         self.layer_norm = nn.LayerNorm(total_features)
# 
#     def forward(self, card_input, state_input):
#         batch_size = card_input.size(0)
#         card_ids = torch.zeros(batch_size, 7, dtype=torch.long, device=card_input.device)
# 
#         suits = ['h', 's', 'd', 'c']
#         ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']
# 
#         for b in range(batch_size):
#             for c in range(7):
#                 if card_input[b, 0, c] > 0 or card_input[b, 1, c] > 0:
#                     suit = int(card_input[b, 0, c] * 3)
#                     rank = int(card_input[b, 1, c] * 12)
#                     card_ids[b, c] = rank * 4 + suit + 1
# 
#         card_embeds = self.card_embedding(card_ids)
#         hole_embeds = card_embeds[:, :2, :].transpose(1, 2)
#         community_embeds = card_embeds[:, 2:, :].transpose(1, 2)
# 
#         hole_features = self.hole_conv(hole_embeds).squeeze(-1)
#         community_features = self.community_conv(community_embeds)
#         community_features = torch.nn.functional.adaptive_avg_pool1d(community_features, 1).squeeze(-1)
# 
#         combined_cards = torch.stack([hole_features, community_features], dim=1)
#         attended_cards, _ = self.attention(combined_cards, combined_cards, combined_cards)
#         attended_cards = attended_cards.mean(dim=1)
# 
#         state_features = torch.nn.functional.relu(self.state_fc(state_input))
# 
#         combined = torch.cat([hole_features, attended_cards, state_features], dim=1)
#         combined = self.layer_norm(combined)
# 
#         x = torch.nn.functional.relu(self.fc1(combined))
#         x = self.dropout(x)
#         x = torch.nn.functional.relu(self.fc2(x))
#         x = self.dropout(x)
#         x = torch.nn.functional.relu(self.fc3(x))
#         x = self.fc4(x)
# 
#         return x
# 
# # Enhanced evaluate_hand function with multi-opponent adjustment
# def evaluate_hand(hole_cards, community_cards, num_opponents=1):
#     evaluator = Evaluator()
# 
#     if len(community_cards) < 3:  # Preflop
#         card1_str = Card.int_to_str(hole_cards[0])
#         card2_str = Card.int_to_str(hole_cards[1])
#         rank1 = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'].index(card1_str[0])
#         rank2 = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'].index(card2_str[0])
# 
#         if rank1 == rank2:
#             equity = 0.5 + (rank1 / 26)
#         elif card1_str[1] == card2_str[1]:
#             equity = 0.3 + (max(rank1, rank2) / 26) + 0.1
#         else:
#             equity = 0.2 + (max(rank1, rank2) / 26)
# 
#         # Adjust equity for multiple opponents
#         equity = equity * (0.85 ** num_opponents)
#         equity = min(equity, 0.85)
# 
#         # Hand strength percentile
#         all_hands = 1326
#         rank = min(rank1, rank2) if rank1 != rank2 else rank1
#         suited = card1_str[1] == card2_str[1]
#         if rank1 == rank2:
#             percentile = 100 * (1 - (6 * (12 - rank) / all_hands))
#         elif suited:
#             percentile = 100 * (1 - (4 * (169 - (rank1 + rank2 + 10)) / all_hands))
#         else:
#             percentile = 100 * (1 - (12 * (169 - (rank1 + rank2)) / all_hands))
# 
#         return 0, 7462, equity, max(0, min(100, percentile))
# 
#     # Post-flop
#     rank = evaluator.evaluate(hole_cards, community_cards)
#     rank_class = evaluator.get_rank_class(rank)
# 
#     equity_map = {
#         1: 0.95, 2: 0.90, 3: 0.85, 4: 0.80, 5: 0.75,
#         6: 0.65, 7: 0.55, 8: 0.40, 9: 0.25
#     }
# 
#     base_equity = equity_map.get(rank_class, 0.25)
#     relative_strength = (7462 - rank) / 7462
#     equity = base_equity + (relative_strength * 0.15)
# 
#     # Adjust for multiple opponents
#     equity = equity * (0.9 ** num_opponents)
#     equity = min(equity, 0.98)
# 
#     # Hand strength percentile
#     percentile = 100 * (1 - rank / 7462)
# 
#     return rank_class, rank, equity, max(0, min(100, percentile))
# 
# # Set up the Streamlit page
# st.set_page_config(page_title="Advanced Poker AI Predictor", page_icon="🃏", layout="wide")
# st.title('Advanced Poker AI Predictor')
# st.write('This app uses a deep Q-learning model to predict the best action in Texas Hold\'em, supporting multiple opponents, visual card selection, and detailed analysis.')
# 
# # Initialize session state for prediction history
# if 'prediction_history' not in st.session_state:
#     st.session_state.prediction_history = []
# 
# # Load the model
# device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
# model = PokerQNetwork().to(device)
# try:
#     model.load_state_dict(torch.load('best_poker_model.pth', map_location=device))
#     model.eval()
#     st.success("Model loaded successfully!")
# except FileNotFoundError:
#     st.error("Model file 'best_poker_model.pth' not found. Please ensure it's in the same directory.")
#     st.stop()
# 
# # Sidebar for user inputs
# st.sidebar.header('Game State Inputs')
# 
# # Number of opponents
# num_opponents = st.sidebar.selectbox('Number of Opponents', [1, 2, 3, 4, 5], index=0)
# 
# # Visual card picker
# st.sidebar.subheader('Card Selection')
# suits = ['♥', '♠', '♦', '♣']
# ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
# deck = [f"{r}{s}" for r in ranks for s in suits]
# 
# def card_image(card_str):
#     if card_str == "None":
#         return None
#     rank = card_str[:-1].lower().replace('10', 'T').replace('j', 'J').replace('q', 'Q').replace('k', 'K').replace('a', 'A')
#     suit = {'♥': 'H', '♠': 'S', '♦': 'D', '♣': 'C'}[card_str[-1]]
#     image_url = f'https://deckofcardsapi.com/static/img/{rank}{suit}.png'
#     return image_url
# 
# # Hole cards
# st.sidebar.write('**Hole Cards**')
# hole_cols = st.sidebar.columns(2)
# hole_cards = []
# selected_cards = []
# for i in range(2):
#     with hole_cols[i]:
#         card_key = f"hole_card_{i}"
#         selected = st.selectbox(f"Card {i+1}", ['None'] + deck, key=card_key)
#         if selected != 'None':
#             hole_cards.append(Card.new(selected[:-1] + {'♥': 'h', '♠': 's', '♦': 'd', '♣': 'c'}[selected[-1]]))
#             selected_cards.append(selected)
#             st.image(card_image(selected), width=80)
# 
# # Community cards
# st.sidebar.subheader('Community Cards')
# stage = st.sidebar.selectbox('Game Stage', ['Preflop', 'Flop', 'Turn', 'River'])
# community_cards = []
# if stage != 'Preflop':
#     num_comm_cards = 3 if stage == 'Flop' else 4 if stage == 'Turn' else 5
#     comm_cols = st.sidebar.columns(num_comm_cards)
#     for i in range(num_comm_cards):
#         with comm_cols[i]:
#             card_key = f"comm_card_{i}"
#             selected = st.selectbox(f"Card {i+1}", ['None'] + deck, key=card_key)
#             if selected != 'None':
#                 community_cards.append(Card.new(selected[:-1] + {'♥': 'h', '♠': 's', '♦': 'd', '♣': 'c'}[selected[-1]]))
#                 selected_cards.append(selected)
#                 st.image(card_image(selected), width=80)
# 
# # Validate card selections
# if len(selected_cards) != len(set(selected_cards)):
#     st.error("Duplicate cards selected. Please choose unique cards.")
#     st.stop()
# 
# if len(hole_cards) != 2:
#     st.error("Please select both hole cards.")
#     st.stop()
# 
# # Game state inputs for player and opponents
# st.sidebar.subheader('Game State')
# pot = st.sidebar.slider('Pot Size ($)', 0, 5000, 50)
# player_stack = st.sidebar.slider('Your Stack ($)', 0, 10000, 1000)
# player_bet = st.sidebar.slider('Your Current Bet ($)', 0, 1000, 0)
# position = st.sidebar.selectbox('Position', ['Early', 'Middle', 'Late'])
# 
# opponent_data = []
# for opp in range(num_opponents):
#     with st.sidebar.expander(f"Opponent {opp+1}"):
#         opp_stack = st.slider(f'Opponent {opp+1} Stack ($)', 0, 10000, 1000, key=f'opp_stack_{opp}')
#         opp_bet = st.slider(f'Opponent {opp+1} Bet ($)', 0, 1000, 10, key=f'opp_bet_{opp}')
#         opp_folded = st.checkbox(f'Opponent {opp+1} Folded', value=False, key=f'opp_folded_{opp}')
#         opp_aggression = st.slider(f'Opponent {opp+1} Aggression (0-1)', 0.0, 1.0, 0.5, key=f'opp_agg_{opp}')
#         opponent_data.append({
#             'stack': opp_stack,
#             'bet': opp_bet,
#             'folded': opp_folded,
#             'aggression': opp_aggression
#         })
# 
# # Prepare input tensors
# card_input = np.zeros((1, 2, 7))
# suits_map = {'h': 0, 's': 1, 'd': 2, 'c': 3}
# ranks_map = {r: i for i, r in enumerate(['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'])}
# all_cards = hole_cards + community_cards
# while len(all_cards) < 7:
#     all_cards.append(0)
# 
# for i, card in enumerate(all_cards[:7]):
#     if card != 0:
#         card_str = Card.int_to_str(card)
#         card_input[0, 0, i] = suits_map[card_str[-1]] / 3.0
#         card_input[0, 1, i] = ranks_map[card_str[0]] / 12.0
# 
# card_input = torch.FloatTensor(card_input).to(device)
# 
# # Encode state (adjusted to 10 features)
# stage_onehot = np.zeros(4)
# stage_idx = ['Preflop', 'Flop', 'Turn', 'River'].index(stage)
# stage_onehot[stage_idx] = 1
# 
# position_bonus = {'Early': 0.0, 'Middle': 0.1, 'Late': 0.2}[position]
# 
# # Aggregate opponent data
# avg_opp_stack = sum(opp['stack'] for opp in opponent_data) / max(1, num_opponents)
# avg_opp_bet = sum(opp['bet'] for opp in opponent_data if not opp['folded']) / max(1, sum(1 for opp in opponent_data if not opp['folded']))
# avg_opp_aggression = sum(opp['aggression'] for opp in opponent_data) / max(1, num_opponents)
# any_opp_folded = any(opp['folded'] for opp in opponent_data)
# 
# state_features = [
#     pot / 1000,
#     player_stack / 1000,
#     avg_opp_stack / 1000,
#     player_bet / 1000,
#     avg_opp_bet / 1000,
#     float(any_opp_folded),
#     avg_opp_aggression,
#     stage_onehot[0],
#     stage_onehot[1],
#     position_bonus
# ]
# 
# state_input = torch.FloatTensor([state_features]).to(device)
# 
# # Display user inputs
# st.subheader('Your Inputs')
# col1, col2 = st.columns([2, 1])
# with col1:
#     st.write('**Hole Cards:**', ', '.join([Card.int_to_pretty_str(c) for c in hole_cards]))
#     st.write('**Community Cards:**', ', '.join([Card.int_to_pretty_str(c) for c in community_cards]) if community_cards else 'None')
#     st.write('**Game State:**')
#     input_data = {
#         'Pot Size ($)': pot,
#         'Your Stack ($)': player_stack,
#         'Your Bet ($)': player_bet,
#         'Avg Opponent Stack ($)': avg_opp_stack,
#         'Avg Opponent Bet ($)': avg_opp_bet,
#         'Any Opponent Folded': any_opp_folded,
#         'Avg Opponent Aggression': avg_opp_aggression,
#         'Game Stage': stage,
#         'Position': position,
#         'Number of Opponents': num_opponents
#     }
#     st.write(pd.DataFrame([input_data]))
# 
# # Display cards
# with col2:
#     st.write('**Your Cards**')
#     cols = st.columns(2)
#     for i, card in enumerate(hole_cards):
#         cols[i].image(card_image(Card.int_to_pretty_str(card)), caption=Card.int_to_pretty_str(card), width=80)
#     if community_cards:
#         st.write('**Community Cards**')
#         cols = st.columns(len(community_cards))
#         for i, card in enumerate(community_cards):
#             cols[i].image(card_image(Card.int_to_pretty_str(card)), caption=Card.int_to_pretty_str(card), width=80)
# 
# # Make prediction
# with torch.no_grad():
#     q_values = model(card_input, state_input)
#     action_probs = torch.softmax(q_values, dim=1).cpu().numpy()[0]
#     action = torch.argmax(q_values, dim=1).item()
# 
# # Evaluate hand strength
# rank_class, rank, equity, percentile = evaluate_hand(hole_cards, community_cards, num_opponents)
# 
# # Store prediction in history
# prediction_entry = {
#     'Timestamp': pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S'),
#     'Hole Cards': ', '.join([Card.int_to_pretty_str(c) for c in hole_cards]),
#     'Community Cards': ', '.join([Card.int_to_pretty_str(c) for c in community_cards]) if community_cards else 'None',
#     'Stage': stage,
#     'Recommended Action': ['Fold', 'Call', 'Raise'][action],
#     'Equity': f'{equity:.2%}',
#     'Hand Strength Percentile': f'{percentile:.1f}%'
# }
# st.session_state.prediction_history.append(prediction_entry)
# if len(st.session_state.prediction_history) > 10:
#     st.session_state.prediction_history = st.session_state.prediction_history[-10:]
# 
# # Display results
# st.subheader('Prediction')
# action_names = ['Fold', 'Call', 'Raise']
# st.write(f'The model recommends to **{action_names[action]}**.')
# st.write(f'Estimated Hand Equity: **{equity:.2%}** (against {num_opponents} opponent(s))')
# st.write(f'Hand Strength Percentile: **{percentile:.1f}%** (top {100-percentile:.1f}% of possible hands)')
# 
# # Action probabilities
# st.subheader('Action Probabilities')
# prob_df = pd.DataFrame({
#     'Action': action_names,
#     'Probability': [f'{p:.2%}' for p in action_probs]
# })
# st.write(prob_df)
# 
# fig = px.bar(
#     x=action_names,
#     y=action_probs,
#     title='Action Probability Distribution',
#     labels={'x': 'Action', 'y': 'Probability'},
#     text=[f'{p:.2%}' for p in action_probs]
# )
# fig.update_traces(textposition='auto')
# fig.update_yaxes(range=[0, 1], tickformat='.0%')
# st.plotly_chart(fig)
# 
# # In-depth analysis
# st.subheader('In-Depth Analysis')
# pot_odds = avg_opp_bet / (pot + avg_opp_bet) if avg_opp_bet > 0 else 0
# st.write(f'**Pot Odds**: {pot_odds:.2%} (you need {pot_odds:.2%} equity to break even on a call)')
# 
# # Stage-specific insights
# stage_insights = {
#     'Preflop': f"In the preflop stage, your hand's equity ({equity:.2%}) is based on starting hand strength against {num_opponents} opponent(s). With a percentile of {percentile:.1f}%, your hand is {'strong' if percentile > 80 else 'medium' if percentile > 50 else 'weak'}. {'Consider raising with strong hands to build the pot.' if percentile > 80 else 'Play cautiously unless position or odds favor you.'}",
#     'Flop': f"On the flop, your equity ({equity:.2%}) reflects your hand's strength with three community cards. A percentile of {percentile:.1f}% indicates {'a strong made hand or draw' if percentile > 70 else 'a moderate hand' if percentile > 40 else 'a weak hand or weak draw'}. {'Aggression may be warranted with strong hands or draws.' if percentile > 70 else 'Evaluate draws carefully against pot odds.'}",
#     'Turn': f"On the turn, with four community cards, your equity ({equity:.2%}) is more defined. Your hand's percentile ({percentile:.1f}%) suggests {'a strong hand or draw' if percentile > 65 else 'a marginal hand' if percentile > 35 else 'a weak hand'}. {'Protect strong hands with bets; consider folding weak hands unless odds are favorable.' if percentile > 65 else 'Be cautious with marginal hands.'}",
#     'River': f"On the river, your hand is fully defined with equity ({equity:.2%}) and percentile ({percentile:.1f}%). This indicates {'a strong hand' if percentile > 60 else 'a medium hand' if percentile > 30 else 'a weak hand'}. {'Value bet strong hands; bluff selectively with weak hands.' if percentile > 60 else 'Check or fold unless pot odds justify a call.'}"
# }
# st.write(f'**Stage Insight ({stage})**: {stage_insights[stage]}')
# 
# # Action analysis
# st.write('**Action Analysis**:')
# for i, action_name in enumerate(action_names):
#     expected_value = 0
#     if action_name == 'Fold':
#         expected_value = 0
#         analysis = "Folding avoids further risk but forfeits the current pot. Recommended with weak hands or poor pot odds."
#     elif action_name == 'Call':
#         if equity > pot_odds + 0.1:
#             expected_value = (equity * pot) - ((1 - equity) * avg_opp_bet)
#             analysis = f"Calling is profitable with {equity:.2%} equity against {pot_odds:.2%} pot odds. Expected value: ${expected_value:.2f}."
#         elif equity > pot_odds:
#             expected_value = (equity * pot) - ((1 - equity) * avg_opp_bet)
#             analysis = f"Calling is marginal with {equity:.2%} equity close to {pot_odds:.2%} pot odds. Expected value: ${expected_value:.2f}."
#         else:
#             expected_value = (equity * pot) - ((1 - equity) * avg_opp_bet)
#             analysis = f"Calling may be unprofitable with {equity:.2%} equity below {pot_odds:.2%} pot odds. Expected value: ${expected_value:.2f}."
#     else:  # Raise
#         raise_amount = avg_opp_bet * 2 if avg_opp_bet > 0 else 20
#         if equity > 0.6:
#             expected_value = (equity * (pot + raise_amount)) - ((1 - equity) * (avg_opp_bet + raise_amount))
#             analysis = f"Raising with a strong hand ({equity:.2%} equity) can build the pot or force folds. Expected value: ${expected_value:.2f}."
#         elif equity > 0.4 and avg_opp_aggression < 0.5:
#             expected_value = (equity * (pot + raise_amount)) - ((1 - equity) * (avg_opp_bet + raise_amount))
#             analysis = f"Raising as a semi-bluff with {equity:.2%} equity may induce folds from less aggressive opponents. Expected value: ${expected_value:.2f}."
#         else:
#             expected_value = (equity * (pot + raise_amount)) - ((1 - equity) * (avg_opp_bet + raise_amount))
#             analysis = f"Raising with {equity:.2%} equity is risky against aggressive opponents. Expected value: ${expected_value:.2f}."
# 
#     st.write(f"- **{action_name}**: {analysis}")
# 
# # Prediction history
# st.subheader('Prediction History (Last 10)')
# if st.session_state.prediction_history:
#     history_df = pd.DataFrame(st.session_state.prediction_history)
#     st.write(history_df)
# else:
#     st.write("No predictions yet.")
#

!pip install -q streamlit treys
!npm install localtunnel
!wget -q -O - ipv4.icanhazip.com
!streamlit run streamlit_app/app.py & npx localtunnel --port 8501
